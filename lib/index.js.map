{"version":3,"sources":["../src/index.js"],"names":["Horizon","defaultHost","window","location","host","defaultSecure","protocol","secure","path","lazyWrites","authType","keepalive","WebSocketCtor","websocket","tokenStorage","setAuthFromQueryParams","url","horizon","name","sendRequest","self","sockets","createSockets","filteredHandshake","switchMap","socket","handshake","filter","subscribe","next","set","token","error","err","test","message","console","remove","currentUser","_hzSocket","disconnect","complete","connect","onError","switch","take","e","status","createStatus","subscribeOrObservable","onDisconnected","x","type","onReady","onSocketError","utensils","Object","freeze","_authMethods","_root","_horizonPath","authEndpoint","hasAuthToken","bind","aggregate","model","options","normalizedType","hzRequest","takeWhile","resp","state","socketsSubject","handshakeMaker","statusSubject","observable","length","Socket","clearAuthTokens"],"mappings":"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","file":"index.js","sourcesContent":["import { BehaviorSubject } from 'rxjs/BehaviorSubject'\n\nimport 'rxjs/add/observable/of'\nimport 'rxjs/add/observable/from'\nimport 'rxjs/add/operator/catch'\nimport 'rxjs/add/operator/concatMap'\nimport 'rxjs/add/operator/map'\nimport 'rxjs/add/operator/filter'\n\nimport { Collection, UserDataTerm } from './ast'\nimport { HorizonSocket } from './socket'\nimport { authEndpoint, TokenStorage, clearAuthTokens } from './auth'\nimport { aggregate, model } from './model'\n\nconst defaultHost = typeof window !== 'undefined' && window.location &&\n        `${window.location.host}` || 'localhost:8181'\nconst defaultSecure = typeof window !== 'undefined' && window.location &&\n        window.location.protocol === 'https:' || false\n\nexport default function Horizon({\n  host = defaultHost,\n  secure = defaultSecure,\n  path = 'horizon',\n  lazyWrites = false,\n  authType = 'unauthenticated',\n  keepalive = 60,\n  WebSocketCtor,\n  websocket,\n} = {}) {\n  // If we're in a redirection from OAuth, store the auth token for\n  // this user in localStorage.\n\n  const tokenStorage = new TokenStorage({ authType, path })\n  tokenStorage.setAuthFromQueryParams()\n\n  const url = `ws${secure ? 's' : ''}:\\/\\/${host}\\/${path}`\n\n  // This is the object returned by the Horizon function. It's a\n  // function so we can construct a collection simply by calling it\n  // like horizon('my_collection')\n  function horizon(name) {\n    return new Collection(sendRequest, name, lazyWrites)\n  }\n  const self = horizon  // For clarity below\n\n  const sockets = createSockets()\n\n\n  // We need to filter out null/undefined handshakes in several places\n  const filteredHandshake = sockets\n          .switchMap(socket => socket.handshake)\n          .filter(handshake => handshake != null)\n\n  // Store whatever token we get back from the server when we get a\n  // handshake response\n  filteredHandshake.subscribe({\n    next(handshake) {\n      if (authType !== 'unauthenticated') {\n        tokenStorage.set(handshake.token)\n      }\n    },\n    error(err) {\n      if (/JsonWebTokenError|TokenExpiredError/.test(err.message)) {\n        console.error('Horizon: clearing token storage since auth failed')\n        tokenStorage.remove()\n      }\n    },\n  })\n\n  self.currentUser = () =>\n    new UserDataTerm(\n      self,\n      filteredHandshake,\n      self._hzSocket\n    )\n\n  self.disconnect = () => {\n    self._hzSocket.complete()\n  }\n\n  // Dummy subscription to force it to connect to the\n  // server. Optionally provide an error handling function if the\n  // socket experiences an error.\n  // Note: Users of the Observable interface shouldn't need this\n  self.connect = (\n    onError = err => { console.error(`Received an error: ${err}`) }\n  ) => {\n    return sockets.switch().take(1).subscribe({\n      error: e => {\n        onError(e)\n      },\n    })\n  }\n\n  const status = createStatus()\n\n  // Either subscribe to status updates, or return an observable with\n  // the current status and all subsequent status changes.\n  self.status = subscribeOrObservable(status)\n\n  // Convenience method for finding out when disconnected\n  self.onDisconnected = subscribeOrObservable(\n    status.filter(x => x.type === 'disconnected'))\n\n  // Convenience method for finding out when ready\n  self.onReady = subscribeOrObservable(\n    status.filter(x => x.type === 'ready'))\n\n  // Convenience method for finding out when an error occurs\n  self.onSocketError = subscribeOrObservable(\n    status.filter(x => x.type === 'error'))\n\n  self.utensils = {\n    sendRequest,\n    tokenStorage,\n  }\n  Object.freeze(self.utensils)\n\n  self._authMethods = null\n  self._root = `http${(secure) ? 's' : ''}://${host}`\n  self._horizonPath = `${self._root}/${path}`\n\n  self.authEndpoint = authEndpoint\n  self.hasAuthToken = tokenStorage.hasAuthToken.bind(tokenStorage)\n  self.aggregate = aggregate\n  self.model = model\n\n  return self\n\n  // Sends a horizon protocol request to the server, and pulls the data\n  // portion of the response out.\n  function sendRequest(type, options) {\n    // Both remove and removeAll use the type 'remove' in the protocol\n    const normalizedType = type === 'removeAll' ? 'remove' : type\n    return sockets.switchMap(socket => socket\n      .hzRequest({ type: normalizedType, options }) // send the raw request\n      .takeWhile(resp => resp.state !== 'complete'))\n  }\n\n  function createSockets() {\n    const socketsSubject = new BehaviorSubject()\n\n    socketsSubject.next(new HorizonSocket({\n      url,\n      handshakeMaker: tokenStorage.handshake.bind(tokenStorage),\n      keepalive,\n      WebSocketCtor,\n      websocket,\n    }))\n\n    return socketsSubject\n  }\n\n  function createStatus() {\n    // Since the underlying socket is going to be swapped out, we need\n    // to create a wrapper BehaviorSubject that is subscribed in turn\n    // to each subsequent HorizonSocket that is created.\n    const statusSubject = new BehaviorSubject()\n    sockets.switchMap(socket => socket.status).subscribe(statusSubject)\n    return statusSubject\n  }\n}\n\nfunction subscribeOrObservable(observable) {\n  return (...args) => {\n    if (args.length > 0) {\n      return observable.subscribe(...args)\n    } else {\n      return observable\n    }\n  }\n}\n\nHorizon.Socket = HorizonSocket\nHorizon.clearAuthTokens = clearAuthTokens\n"]}