{"version":3,"sources":["../src/resilient-socket.js"],"names":["connectionSmoother","SocketWrapper","url","handshakeMaker","keepalive","WebSocketCtor","WebSocket","websocket","requestCounter","status","handshakes","websockets","infiniteSockets","protocol","socket","openObserver","sendHandshake","closingObserver","next","closeObserver","cleanupHandshake","timer","switchMap","makeRequest","type","_handshakeSub","_handshakeMaker","subscribe","n","error","handshake","error_code","ws","e","add","connect","send","msg","filter","x","take","map","JSON","stringify","rawRequest","shouldEndSubscription","request_id","request","Object","assign","subscription","resp","undefined","observer","data","d","state","complete","err","unsubscribe","horizonParams","controlSignals","sockets","infiniteHorizonSockets","statuses","cache","sendRequest","clientType","options","share","disconnect","signals","params","signalName"],"mappings":"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","file":"resilient-socket.js","sourcesContent":["import { AsyncSubject } from 'rxjs/AsyncSubject'\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject'\nimport { Subject } from 'rxjs/Subject'\nimport { WebSocketSubject } from 'rxjs/observable/dom/WebSocketSubject'\nimport { Observable } from 'rxjs/Observable'\nimport 'rxjs/add/observable/merge'\nimport 'rxjs/add/observable/never'\nimport 'rxjs/add/observable/timer'\nimport 'rxjs/add/observable/defer'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/share'\nimport 'rxjs/add/operator/ignoreElements'\nimport 'rxjs/add/operator/concat'\nimport 'rxjs/add/operator/takeWhile'\nimport 'rxjs/add/operator/publish'\nimport 'rxjs/add/operator/cache'\n\n\nimport { PROTOCOL_VERSION,\n         ProtocolError,\n         STATUS_UNCONNECTED,\n         STATUS_READY,\n         STATUS_ERROR,\n         STATUS_CLOSING,\n         STATUS_DISCONNECTED,\n       } from './socket'\nimport { serialize, deserialize } from './serialization'\n\n\nexport class SocketWrapper {\n  constructor({\n    url,              // Full url to connect to\n    handshakeMaker, // function that returns handshake to emit\n    keepalive = 60,   // seconds between keepalive messages\n    WebSocketCtor = WebSocket,    // optionally provide a WebSocket constructor\n    websocket,\n  }) {\n    this.requestCounter = 0\n    this.status = new BehaviorSubject(STATUS_UNCONNECTED)\n    this.handshakes = new BehaviorSubject()\n    this.handshakeMaker = handshakeMaker\n    this.websockets = infiniteSockets({\n      url,\n      protocol: PROTOCOL_VERSION,\n      socket: websocket,\n      WebSocketCtor,\n      openObserver: () => {\n        this.sendHandshake()\n      },\n      closingObserver: () => this.status.next(STATUS_CLOSING),\n      closeObserver: () => {\n        this.status.next(STATUS_DISCONNECTED)\n        this.cleanupHandshake()\n      },\n    })\n    this.keepalive = Observable\n      .timer(keepalive * 1000, keepalive * 1000)\n      .switchMap(() => this.makeRequest({ type: 'keepalive' }))\n  }\n\n  // Send the handshake if it hasn't been sent already. It also starts\n  // the keepalive observable and cleans up after it when the\n  // handshake is cleaned up.\n  sendHandshake() {\n    if (!this._handshakeSub) {\n      this._handshakeSub = this.makeRequest(this._handshakeMaker())\n        .subscribe({\n          next: n => {\n            if (n.error) {\n              this.status.next(STATUS_ERROR)\n              this.handshake.error(new ProtocolError(n.error, n.error_code))\n            } else {\n              this.status.next(STATUS_READY)\n              this.handshakes.next(n)\n            }\n          },\n          error: e => {\n            this.status.next(STATUS_ERROR)\n            this.handshakes.next(null)\n            this.cleanupHandshake()\n            this.ws.error(e)\n          },\n        })\n\n      // Start the keepalive and make sure it's\n      // killed when the handshake is cleaned up\n      this._handshakeSub.add(this.keepalive.connect())\n    }\n    return this.handshakes\n  }\n\n  send(msg) {\n    this.handshakes\n      .filter(x => x !== null)\n      .take(1)\n      // Any handshake will be mapped to the request\n      .map(() => JSON.stringify(serialize(msg)))\n      // The websocket's next method will be called with the request\n      .subscribe(this.ws)\n  }\n\n  makeRequest(rawRequest, shouldEndSubscription = true, handshake = false) {\n    return new Observable(observer => {\n      const request_id = this.requestCounter++\n      const request = Object.assign({ request_id }, request)\n\n      if (handshake) {\n        this.ws.next(JSON.stringify(serialize(request)))\n      } else {\n        this.send(request)\n      }\n\n      const subscription = this.ws.subscribe({\n        next(resp) {\n          // Multiplex by request id on all incoming messages\n          if (resp.request_id === request_id) {\n            if (resp.error !== undefined) {\n              observer.error(ProtocolError(resp.error, resp.error_code))\n            }\n            for (const d of resp.data) {\n              // Only need to deserialize data coming back\n              observer.next(deserialize(d))\n            }\n            if (resp.state !== undefined) {\n              // Create a little dummy object for sync notifications\n              observer.next({\n                type: 'state',\n                state: resp.state,\n              })\n            }\n            if (resp.state === 'complete') {\n              observer.complete()\n            }\n          }\n        },\n        error(err) { observer.error(err) },\n        complete() { observer.complete() },\n      })\n\n      return () => {\n        if (shouldEndSubscription) {\n          this.send({ request_id, type: 'end_subscription' })\n        }\n        subscription.unsubscribe()\n      }\n    })\n  }\n}\n\n\nexport function connectionSmoother(horizonParams) {\n  const controlSignals = new Subject()\n  const sockets = infiniteHorizonSockets(controlSignals, horizonParams)\n  const statuses = sockets.switchMap(socket => socket.status).cache(1)\n\n  return {\n    controlSignals,\n    sockets,\n    handshakes: sockets.switchMap(socket => socket.handshake),\n    statuses,\n    sendRequest(clientType, options) {\n      const type = clientType === 'removeAll' ? 'remove' : clientType\n      return sockets\n        // Each time we get a new socket, we'll send the request\n        .switchMap(socket => socket.makeRequest({ type, options }))\n        // Share to prevent re-sending requests whenever a subscriber shows up\n        .share()\n    },\n    connect() {\n      controlSignals.next('connect')\n    },\n    disconnect() {\n      controlSignals.next('disconnect')\n    },\n  }\n}\n\nfunction infiniteSockets(signals, params) {\n  return signals\n    // We only care about two signals\n    .filter(x => x === 'connect' || x === 'disconnect')\n    // Create a new socket if we're to connect\n    .map(signalName => {\n      if (signalName === 'connect') {\n        return new WebSocketSubject(params)\n      } else {\n        return signalName\n      }\n    })\n    // Cache the last socket so we don't keep creating them on subscribe\n    .cache(1)\n    // Filter out disconnect signals so new subscribers don't get the cached\n    // horizon socket after a disconnect message\n    .filter(x => x === 'disconnect')\n}\n"]}