{"version":3,"sources":["../src/socket.js"],"names":["PROTOCOL_VERSION","STATUS_UNCONNECTED","type","STATUS_READY","STATUS_ERROR","STATUS_CLOSING","STATUS_DISCONNECTED","ProtocolError","msg","errorCode","toString","message","Error","HorizonSocket","resultSelector","e","JSON","parse","data","next","value","request","stringify","url","handshakeMaker","keepalive","WebSocketCtor","WebSocket","websocket","protocol","socket","openObserver","sendHandshake","closingObserver","status","closeObserver","cleanupHandshake","handshake","_handshakeMaker","_handshakeSub","timer","switchMap","makeRequest","requestCounter","activeRequests","Map","_output","subscribe","error","unsubscribe","getRequest","Object","assign","request_id","n","error_code","complete","add","connect","rawRequest","shouldEndSub","self","requestSent","observer","subscription","resp","undefined","d","state","err"],"mappings":"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","file":"socket.js","sourcesContent":["import { AsyncSubject } from 'rxjs/AsyncSubject'\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject'\nimport { Subject } from 'rxjs/Subject'\nimport { WebSocketSubject } from 'rxjs/observable/dom/WebSocketSubject'\nimport { Observable } from 'rxjs/Observable'\nimport 'rxjs/add/observable/merge'\nimport 'rxjs/add/observable/never'\nimport 'rxjs/add/observable/timer'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/share'\nimport 'rxjs/add/operator/ignoreElements'\nimport 'rxjs/add/operator/concat'\nimport 'rxjs/add/operator/takeWhile'\nimport 'rxjs/add/operator/publish'\nimport 'rxjs/add/operator/cache'\n\nimport { serialize, deserialize } from './serialization.js'\n\nexport const PROTOCOL_VERSION = 'rethinkdb-horizon-v0'\n\n// Before connecting the first time\nexport const STATUS_UNCONNECTED = { type: 'unconnected' }\n// After the websocket is opened and handshake is completed\nexport const STATUS_READY = { type: 'ready' }\n// After unconnected, maybe before or after connected. Any socket level error\nexport const STATUS_ERROR = { type: 'error' }\n// Occurs right before socket closes\nexport const STATUS_CLOSING = { type: 'closing' }\n// Occurs when the socket closes\nexport const STATUS_DISCONNECTED = { type: 'disconnected' }\n\nexport class ProtocolError extends Error {\n  constructor(msg, errorCode) {\n    super(msg)\n    this.errorCode = errorCode\n  }\n  toString() {\n    return `${this.message} (Code: ${this.errorCode})`\n  }\n}\n\n// Wraps native websockets with a Subject, which is both an Subscriber\n// and an Observable (it is bi-directional after all!). This version\n// is based on the rxjs.observable.dom.WebSocketSubject implementation.\nexport class HorizonSocket extends WebSocketSubject {\n  // Deserializes a message from a string. Overrides the version\n  // implemented in WebSocketSubject\n  resultSelector(e) {\n    return deserialize(JSON.parse(e.data))\n  }\n\n  // We're overriding the next defined in AnonymousSubject so we\n  // always serialize the value. When this is called a message will be\n  // sent over the socket to the server.\n  next(value) {\n    const request = JSON.stringify(serialize(value))\n    super.next(request)\n  }\n\n  constructor({\n    url,              // Full url to connect to\n    handshakeMaker, // function that returns handshake to emit\n    keepalive = 60,   // seconds between keepalive messages\n    WebSocketCtor = WebSocket,    // optionally provide a WebSocket constructor\n    websocket,\n  } = {}) {\n    super({\n      url,\n      protocol: PROTOCOL_VERSION,\n      socket: websocket,\n      WebSocketCtor,\n      openObserver: {\n        next: () => this.sendHandshake(),\n      },\n      closingObserver: {\n        next: () => {\n          this.status.next(STATUS_CLOSING)\n        },\n      },\n      closeObserver: {\n        next: () => {\n          this.status.next(STATUS_DISCONNECTED)\n          this.cleanupHandshake()\n        },\n      },\n    })\n\n    // some new lines here\n    // Completes or errors based on handshake success. Buffers\n    // handshake response for later subscribers (like a Promise)\n    this.handshake = new AsyncSubject()\n    this._handshakeMaker = handshakeMaker\n    this._handshakeSub = null\n\n    this.keepalive = Observable\n      .timer(keepalive * 1000, keepalive * 1000)\n      .switchMap(() => this.makeRequest({ type: 'keepalive' }))\n\n    // This is used to emit status changes that others can hook into.\n    this.status = new BehaviorSubject(STATUS_UNCONNECTED)\n    // Keep track of subscribers so we's can decide when to\n    // unsubscribe.\n    this.requestCounter = 0\n    // A map from request_ids to an object with metadata about the\n    // request. Eventually, this should allow re-sending requests when\n    // reconnecting.\n    this.activeRequests = new Map()\n    this._output.subscribe({\n      // This emits if the entire socket errors (usually due to\n      // failure to connect)\n      error: () => this.status.next(STATUS_ERROR),\n    })\n  }\n\n  cleanupHandshake() {\n    if (this._handshakeSub) {\n      this._handshakeSub.unsubscribe()\n    }\n  }\n\n  getRequest(request) {\n    return Object.assign({ request_id: this.requestCounter++ }, request)\n  }\n\n  // Send the handshake if it hasn't been sent already. It also starts\n  // the keepalive observable and cleans up after it when the\n  // handshake is cleaned up.\n  sendHandshake() {\n    if (!this._handshakeSub) {\n      this._handshakeSub = this.makeRequest(this._handshakeMaker())\n        .subscribe({\n          next: n => {\n            if (n.error) {\n              this.status.next(STATUS_ERROR)\n              this.handshake.error(new ProtocolError(n.error, n.error_code))\n            } else {\n              this.status.next(STATUS_READY)\n              this.handshake.next(n)\n              this.handshake.complete()\n            }\n          },\n          error: e => {\n            this.status.next(STATUS_ERROR)\n            this.handshake.error(e)\n            this.cleanupHandshake()\n            this.error(e)\n          },\n        })\n\n      // Start the keepalive and make sure it's\n      // killed when the handshake is cleaned up\n      this._handshakeSub.add(this.keepalive.connect())\n    }\n    return this.handshake\n  }\n\n  // Incorporates shared logic between the inital handshake request and\n  // all subsequent requests.\n  // * Generates a request id and filters by it\n  // * Send `end_subscription` when observable is unsubscribed\n  makeRequest(rawRequest, shouldEndSub = true) {\n    return new Observable(observer => {\n      const self = this\n      const request = this.getRequest(rawRequest)\n      const { request_id } = request\n      let requestSent = false\n      self.sendHandshake().subscribe({\n        error(e) {\n          observer.error(e) // error request if the handshake errors\n        },\n        complete() {\n          self.next(request) // send the request when the handshake is done\n          requestSent = true\n        },\n      })\n\n      const subscription = self.subscribe({\n        next(resp) {\n          // Multiplex by request id on all incoming messages\n          if (resp.request_id === request_id) {\n            if (resp.error !== undefined) {\n              observer.error(ProtocolError(resp.error, resp.error_code))\n            }\n            for (const d of resp.data) {\n              observer.next(d)\n            }\n            if (resp.state !== undefined) {\n              // Create a little dummy object for sync notifications\n              observer.next({\n                type: 'state',\n                state: resp.state,\n              })\n            }\n            if (resp.state === 'complete') {\n              observer.complete()\n            }\n          }\n        },\n        error(err) { observer.error(err) },\n        complete() { observer.complete() },\n      })\n\n      return () => {\n        if (requestSent && shouldEndSub) {\n          self.next({ request_id, type: 'end_subscription' })\n        }\n        subscription.unsubscribe()\n      }\n    })\n  }\n}\n"]}